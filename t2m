#!/usr/bin/env python

from __future__ import print_function

import os
import sys
import json
import time
import shutil
import tempfile
import codecs

try:
    from urllib import urlretrieve
except ImportError:
    from urllib.request import urlretrieve

from getpass import getpass

import yaml
import argh
import twitter

from mastodon import Mastodon

try:
    from HTMLParser import HTMLParser
except ImportError:
    from html.parser import HTMLParser


def _get_db(path="db.json"):
    if os.path.isfile(path):
        with open(path) as fobj:
            return json.load(fobj)
    return {}


def _save_db(db, path="db.json"):
    with open(path, "w") as fobj:
        json.dump(db, fobj, indent=4)


def _ensure_client_exists_for_instance(instance):
    client_id = "t2m_%s_clientcred.txt" % instance
    if not os.path.exists(client_id):
        Mastodon.create_app('t2m', to_file=client_id,
                            api_base_url='https://%s' % instance,
                            )
    return client_id


def _check_complete_mastodon_handle(mastodon_handle, twitter_handle):
    if "@" not in mastodon_handle:
        msg = ("ERROR: multiple instances are now handled, but your mastodon"
               " handle %(mastodon)r needs the instance name. Please add it"
               " using:\n%(exe)s add %(twitter)s %(mastodon)s@theinstance.com")
        ctx = {"exe": sys.argv[0],
               "twitter": twitter_handle,
               "mastodon": mastodon_handle}
        print(msg % ctx, file=sys.stderr)
        sys.exit(1)


def _forward(db, twitter_handle, mastodon_handle, number=None,
             only_mark_as_seen=False, retweets=False, debug=False):

    with open("conf.yaml") as fobj:
        t = twitter.Api(tweet_mode='extended', **yaml.safe_load(fobj))

    _check_complete_mastodon_handle(mastodon_handle, twitter_handle)

    mastodon_nick, instance = mastodon_handle.split("@", 1)

    client_id, access_token = _login_to_mastodon(mastodon_handle)

    mastodon = Mastodon(client_id=client_id,
                        access_token=access_token,
                        api_base_url='https://%s' % instance)

    to_toot = []

    if retweets:
        with codecs.open("retweet.tmpl", encoding="utf-8") as f:
            retweet_template = f.read()

    # select tweets first
    for i in reversed(t.GetUserTimeline(screen_name=twitter_handle,
                                        count=200)):

        retweeted_status = i.retweeted_status or i.quoted_status

        if retweeted_status:
            if retweets:
                text = retweet_template % {
                    "text": retweeted_status.full_text,
                    "user": retweeted_status.user.screen_name,
                    "id": retweeted_status.id
                }

                if i.quoted_status:
                    text = i.full_text + "\n\n" + text

                urls = retweeted_status.urls
                media = retweeted_status.media
            else:
                continue
        else:
            # do not forward pseudo-private answer for now
            if i.full_text.startswith("@"):
                continue

            text = i.full_text
            urls = i.urls
            media = i.media

        # do not forward already forwarded tweets
        if i.id in db.get(twitter_handle, {}).setdefault("done", []):
            continue

        # remove this t.co crap
        for url in urls:
            text = text.replace(url.url, url.expanded_url)

        if not only_mark_as_seen:
            h = HTMLParser()
            to_toot.append({
                "text": h.unescape(text),
                "id": i.id,
                "medias": [x.media_url for x in media] if media else []
            })
        else:
            db.setdefault(twitter_handle, {}).setdefault("done", []).append(
                i.id)

    # slices selected tweets if specified
    if number is not None:
        to_toot = to_toot[-int(number):]

    tmp_dir = tempfile.mkdtemp()

    forwarded = 0
    # actually forward
    if not only_mark_as_seen:
        for toot in to_toot:
            if debug:
                print(">>", toot["text"].encode("Utf-8"),
                      " ".join(toot["medias"]))
            else:
                try:
                    medias = []
                    for number, media_url in enumerate(toot["medias"]):
                        dl_file_path = os.path.join(tmp_dir, str(number) + "."
                                                    + media_url.split(".")[-1])
                        urlretrieve(media_url, dl_file_path)
                        medias.append(mastodon.media_post(dl_file_path)["id"])

                    response = mastodon.status_post(toot["text"],
                                                    media_ids=medias)
                    assert not response.get("error"), response
                    forwarded += 1
                except Exception as e:
                    import traceback
                    traceback.print_exc()
                    print("ERROR: could not forward the twitt [%s] '%s' "
                          "because '%s', skipping for now"
                          % (toot["id"], toot["text"], e))
                    continue

                print("[forwarding] >>",
                      toot["text"].encode("Utf-8"),
                      " ".join(toot["medias"]))
                db.setdefault(twitter_handle, {}).setdefault(
                    "done", []).append(toot["id"])
                _save_db(db)
                time.sleep(30)

    if only_mark_as_seen:
        print("Mark all available tweets as seen")
    elif not to_toot:
        print("Nothing to do for %s" % twitter_handle)
    else:
        print("Forwarded %s tweets from %s to %s"
              % (forwarded, twitter_handle, mastodon_handle))

    shutil.rmtree(tmp_dir, ignore_errors=True)

    return db


def one(twitter_handle, mastodon_handle=None, number=None,
        only_mark_as_seen=False, retweets=False, debug=False):

    db = _get_db()

    if mastodon_handle is None:
        if twitter_handle not in db:
            print("ERROR: No associated mastodon account for twitter account"
                  " %r. Use the '-m' option to provide one." % twitter_handle,
                  file=sys.stderr)
            sys.exit(1)
        else:
            mastodon_handle = db[twitter_handle]["mastodon"]

    _check_complete_mastodon_handle(mastodon_handle, twitter_handle)

    # force set new mastodon handle
    db.setdefault(twitter_handle, {})["mastodon"] = mastodon_handle

    db = _forward(db, twitter_handle, mastodon_handle, number=number,
                  only_mark_as_seen=only_mark_as_seen, retweets=retweets,
                  debug=debug)

    _save_db(db)


def all(retweets=False, debug=False):
    db = _get_db()

    for twitter_handle in db:
        if not db[twitter_handle].get("mastodon"):
            print("WARNING: no mastodon handle for twitter account %r, "
                  "add one using the 't2m add' command. Skipped."
                  % twitter_handle)
            continue

        db = _forward(db, twitter_handle, db[twitter_handle]["mastodon"],
                      retweets=retweets, debug=debug)

    _save_db(db)


def _login_to_mastodon(mastodon_handle):
    mastodon_nick, instance = mastodon_handle.split("@", 1)
    client_id = _ensure_client_exists_for_instance(instance)
    access_token = "t2m_%s_creds.txt" % mastodon_handle
    if not os.path.exists(access_token):
        mastodon = Mastodon(client_id=client_id,
                            api_base_url="https://%s" % instance)

        print("No credential file found for mastodon account %r, "
              "creating it (the password will NOT be saved)" % mastodon_handle)
        mastodon.log_in(
            argh.io.safe_input(
                "Email for mastodon account %r: " % mastodon_handle).strip(),
            getpass("Password for mastodon account of '%s' (won't be stored): "
                    % mastodon_handle),
            to_file=access_token,
        )
    return client_id, access_token


def add(twitter_handle, mastodon_handle):
    db = _get_db()

    _check_complete_mastodon_handle(mastodon_handle, twitter_handle)

    # retrocompatibility
    access_token = "t2m_%s_creds.txt" % mastodon_handle
    if os.path.exists("t2m_%s_creds.txt" % mastodon_handle.split("@")[0]):
        shutil.move("t2m_%s_creds.txt" % mastodon_handle.split("@")[0],
                    access_token)

    _login_to_mastodon(mastodon_handle)

    db.setdefault(twitter_handle, {})["mastodon"] = mastodon_handle

    _save_db(db)
    print("done")


def list():
    db = _get_db()
    for i in db:
        print(" *", i)


if __name__ == '__main__':
    if not os.path.exists("conf.yaml"):
        print("You need to have a conf.yaml file containing twitter connection"
              " informations, please read the documentation"
              " https://github.com/Psycojoker/t2m#installation")
        sys.exit(1)

    parser = argh.ArghParser()
    parser.add_commands([one, all, add, list])
    parser.dispatch()
